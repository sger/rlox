// src/bin/generate_ast.rs
use std::env;
use std::fs::{self, File};
use std::io::{self, Write};
use std::path::{Path, PathBuf};

fn main() -> io::Result<()> {
    let mut args = env::args().skip(1);
    let output_dir = match args.next() {
        Some(p) if args.next().is_none() => p,
        _ => {
            eprintln!("Usage: generate_ast <output directory>");
            std::process::exit(64);
        }
    };

    define_ast(
        &output_dir,
        "Expr",
        &[
            "Assign   : Token name, Expr value",
            "Binary   : Expr left, Token operator, Expr right",
            "Call     : Expr callee, Token paren, List<Expr> arguments",
            "Get      : Expr object, Token name",
            "Grouping : Expr expression",
            "Literal  : Object value",
            "Logical  : Expr left, Token operator, Expr right",
            "Set      : Expr object, Token name, Expr value",
            "Super    : Token keyword, Token method",
            "This     : Token keyword",
            "Unary    : Token operator, Expr right",
            "Variable : Token name",
        ],
    )?;

    define_ast(
        &output_dir,
        "Stmt",
        &[
            "Block      : List<Stmt> statements",
            "Class      : Token name, Expr.Variable superclass, List<Stmt.Function> methods",
            "Expression : Expr expression",
            "Function   : Token name, List<Token> params, List<Stmt> body",
            "If         : Expr condition, Stmt thenBranch, Stmt elseBranch",
            "Print      : Expr expression",
            "Return     : Token keyword, Expr value",
            "Var        : Token name, Expr initializer",
            "While      : Expr condition, Stmt body",
        ],
    )?;

    Ok(())
}

fn define_ast(output_dir: &str, base_name: &str, types: &[&str]) -> io::Result<()> {
    fs::create_dir_all(output_dir)?;

    let filename = format!("{}.rs", base_name.to_lowercase());
    let path: PathBuf = Path::new(output_dir).join(filename);
    let mut w = File::create(path)?;

    writeln!(
        w,
        "// AUTO-GENERATED by src/bin/generate_ast.rs. Do not hand-edit."
    )?;
    writeln!(w)?;
    writeln!(w, "use crate::token::Token;")?;
    writeln!(w, "use crate::value::Value;")?;
    writeln!(w)?;
    writeln!(w, "pub type Object = Value;")?;
    writeln!(w)?;

    // Enum
    writeln!(w, "#[derive(Debug, Clone)]")?;
    writeln!(w, "pub enum {base} {{", base = base_name)?;
    for t in types {
        let (variant, fields) = split_type(t);
        let rust_fields = parse_fields(&fields);

        writeln!(w, "    {variant} {{", variant = variant)?;
        for (fname, fty) in rust_fields {
            writeln!(w, "        {fname}: {fty},")?;
        }
        writeln!(w, "    }},")?;
    }
    writeln!(w, "}}")?;
    writeln!(w)?;

    define_visitor(&mut w, base_name, types)?;
    define_accept(&mut w, base_name, types)?;

    Ok(())
}

fn define_visitor<W: Write>(w: &mut W, base_name: &str, types: &[&str]) -> io::Result<()> {
    let trait_name = format!("{base_name}Visitor");
    writeln!(w, "pub trait {trait_name}<R> {{")?;

    for t in types {
        let (variant, fields) = split_type(t);
        let method = format!("visit_{}_{}", to_snake(&variant), base_name.to_lowercase());

        let rust_fields = parse_fields(&fields);
        let params = rust_fields
            .into_iter()
            .map(|(n, ty)| format!("{n}: &{}", visitor_ref_type(&ty)))
            .collect::<Vec<_>>()
            .join(", ");

        writeln!(w, "    fn {method}(&mut self, {params}) -> R;")?;
    }

    writeln!(w, "}}")?;
    writeln!(w)?;
    Ok(())
}

fn define_accept<W: Write>(w: &mut W, base_name: &str, types: &[&str]) -> io::Result<()> {
    let trait_name = format!("{base_name}Visitor");

    writeln!(w, "impl {base_name} {{")?;
    writeln!(
        w,
        "    pub fn accept<R, V: {trait_name}<R>>(&self, visitor: &mut V) -> R {{"
    )?;
    writeln!(w, "        match self {{")?;

    for t in types {
        let (variant, fields) = split_type(t);
        let method = format!("visit_{}_{}", to_snake(&variant), base_name.to_lowercase());

        let rust_fields = parse_fields(&fields);

        let bind_list = rust_fields
            .iter()
            .map(|(n, _)| n.as_str())
            .collect::<Vec<_>>()
            .join(", ");

        let args = rust_fields
            .iter()
            .map(|(n, ty)| arg_expr(n, ty))
            .collect::<Vec<_>>()
            .join(", ");

        writeln!(
            w,
            "            {base}::{variant} {{ {bind_list} }} => visitor.{method}({args}),",
            base = base_name,
            variant = variant,
            bind_list = bind_list,
            method = method,
            args = args
        )?;
    }

    writeln!(w, "        }}")?;
    writeln!(w, "    }}")?;
    writeln!(w, "}}")?;
    writeln!(w)?;
    Ok(())
}

fn parse_fields(field_list: &str) -> Vec<(String, String)> {
    if field_list.trim().is_empty() {
        return vec![];
    }

    field_list
        .split(',') // split fields by comma
        .map(|f| f.trim())
        .filter(|f| !f.is_empty())
        .map(|f| {
            // field is like "Token name" or "Expr.Variable superclass"
            let mut it = f.split_whitespace();
            let ty = it.next().unwrap();
            let raw_name = it.next().unwrap_or("field");

            // strip any trailing punctuation (extra safety)
            let name = raw_name.trim_end_matches(|c: char| !c.is_ascii_alphanumeric() && c != '_');

            let rust_ty = map_type(ty);
            (to_snake(name), rust_ty)
        })
        .collect()
}

// fn map_type(java_ty: &str) -> String {
//     // For Expr.Variable / Stmt.Function etc, only take the base.
//     let simplified = java_ty.split('.').next().unwrap_or(java_ty);

//     match simplified {
//         "List<Expr>" => "Vec<Expr>".to_string(),
//         "List<Stmt>" => "Vec<Stmt>".to_string(),
//         "List<Token>" => "Vec<Token>".to_string(),

//         "Expr" => "Box<Expr>".to_string(),
//         "Stmt" => "Box<Stmt>".to_string(),

//         "Token" => "Token".to_string(),
//         "Object" => "Object".to_string(),

//         other => other.to_string(),
//     }
// }

fn map_type(java_ty: &str) -> String {
    // Handle List<...> first
    if let Some(inner) = java_ty
        .strip_prefix("List<")
        .and_then(|s| s.strip_suffix('>'))
    {
        let base = inner.split('.').next().unwrap();
        return match base {
            "Expr" => "Vec<Expr>".to_string(),
            "Stmt" => "Vec<Stmt>".to_string(),
            "Token" => "Vec<Token>".to_string(),
            other => format!("Vec<{other}>"),
        };
    }

    // Handle dotted types like Expr.Variable, Stmt.Function
    let simplified = java_ty.split('.').next().unwrap_or(java_ty);

    match simplified {
        "Expr" => "Box<Expr>".to_string(),
        "Stmt" => "Box<Stmt>".to_string(),
        "Token" => "Token".to_string(),
        "Object" => "Object".to_string(),
        other => other.to_string(),
    }
}

// Visitor wants &Expr, not &Box<Expr>
fn visitor_ref_type(ty: &str) -> String {
    if let Some(inner) = ty.strip_prefix("Box<").and_then(|s| s.strip_suffix('>')) {
        inner.to_string()
    } else {
        ty.to_string()
    }
}

// When passing args to visitor, boxed fields should pass &Expr, not &Box<Expr>
fn arg_expr(name: &str, ty: &str) -> String {
    if ty.starts_with("Box<") {
        format!("&**{name}")
    } else {
        name.to_string()
    }
}

fn to_snake(s: &str) -> String {
    let mut out = String::new();
    for (i, ch) in s.chars().enumerate() {
        if ch.is_uppercase() {
            if i != 0 {
                out.push('_');
            }
            out.extend(ch.to_lowercase());
        } else {
            out.push(ch);
        }
    }
    out
}

fn split_type(line: &str) -> (String, String) {
    let mut parts = line.split(':');
    let left = parts.next().unwrap().trim().to_string();
    let right = parts.next().unwrap_or("").trim().to_string();
    (left.split_whitespace().next().unwrap().to_string(), right)
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::fs;

    fn generate_into_temp() -> (String, String) {
        let dir = tempfile::tempdir().expect("tempdir");
        let out = dir.path().to_string_lossy().to_string();

        define_ast(
            &out,
            "Expr",
            &[
                "Assign   : Token name, Expr value",
                "Binary   : Expr left, Token operator, Expr right",
                "Call     : Expr callee, Token paren, List<Expr> arguments",
                "Get      : Expr object, Token name",
                "Grouping : Expr expression",
                "Literal  : Object value",
                "Logical  : Expr left, Token operator, Expr right",
                "Set      : Expr object, Token name, Expr value",
                "Super    : Token keyword, Token method",
                "This     : Token keyword",
                "Unary    : Token operator, Expr right",
                "Variable : Token name",
            ],
        )
        .expect("define_ast Expr");

        define_ast(
            &out,
            "Stmt",
            &[
                "Block      : List<Stmt> statements",
                "Class      : Token name, Expr.Variable superclass, List<Stmt.Function> methods",
                "Expression : Expr expression",
                "Function   : Token name, List<Token> params, List<Stmt> body",
                "If         : Expr condition, Stmt thenBranch, Stmt elseBranch",
                "Print      : Expr expression",
                "Return     : Token keyword, Expr value",
                "Var        : Token name, Expr initializer",
                "While      : Expr condition, Stmt body",
            ],
        )
        .expect("define_ast Stmt");

        let expr = fs::read_to_string(dir.path().join("expr.rs")).expect("read expr.rs");
        let stmt = fs::read_to_string(dir.path().join("stmt.rs")).expect("read stmt.rs");

        // Keep tempdir alive until reads are done
        drop(dir);

        (expr, stmt)
    }

    #[test]
    fn expr_assign_has_name_and_value() {
        let (expr, _) = generate_into_temp();

        assert!(expr.contains("pub enum Expr"), "missing Expr enum");
        assert!(
            expr.contains("Assign {")
                && expr.contains("name: Token")
                && expr.contains("value: Box<Expr>"),
            "Assign variant fields/types wrong:\n{expr}"
        );
    }

    #[test]
    fn expr_call_has_arguments_vec_expr() {
        let (expr, _) = generate_into_temp();

        assert!(
            expr.contains("Call {")
                && expr.contains("callee: Box<Expr>")
                && expr.contains("paren: Token")
                && expr.contains("arguments: Vec<Expr>"),
            "Call variant wrong:\n{expr}"
        );
    }

    #[test]
    fn stmt_class_methods_are_vec_stmt_not_list() {
        let (_, stmt) = generate_into_temp();

        // This catches the earlier "List<Stmt," bug.
        assert!(
            stmt.contains("methods: Vec<Stmt>"),
            "Class.methods should be Vec<Stmt>:\n{stmt}"
        );

        // Ensure no raw 'List<' leaked into output.
        assert!(
            !stmt.contains("List<"),
            "Output should not contain Java List<...>:\n{stmt}"
        );
    }

    #[test]
    fn visitor_signatures_use_refs_and_deref_boxes() {
        let (expr, stmt) = generate_into_temp();

        // Because we generate Box<Expr> fields but visitor wants &Expr
        assert!(
            expr.contains(
                "fn visit_binary_expr(&mut self, left: &Expr, operator: &Token, right: &Expr) -> R;"
            ) || expr.contains(
                "fn visit_binary_expr(&mut self, left: &Expr, operator: &Token, right: &Expr) -> R;"
            ),
            "Binary visitor signature should take &Expr and &Token:\n{expr}"
        );

        // And accept() should deref boxes when calling visitor: &**field
        assert!(
            stmt.contains("&**superclass") || stmt.contains("&**condition"),
            "accept() should deref Box fields when calling visitor:\n{stmt}"
        );
    }
}
